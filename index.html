 <!DOCTYPE html>
 <html>
    <head>
        <title>My first three.js app</title>
        <style>
          body {
	background-color: #000;
	margin: 0px;
	overflow: hidden;
}

h1 {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1;
  text-align: center;
}

			body {
				color: #444;
			}
			a {
				color: #08f;
			}
	

        </style>
    </head>
    <body>
      <script type="x-shader/x-vertex" id="vertexShader">

        varying vec3 vWorldPosition;
  
        void main() {
  
          vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
          vWorldPosition = worldPosition.xyz;
  
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
        }
  
      </script>
  
      <script type="x-shader/x-fragment" id="fragmentShader">
  
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
  
        varying vec3 vWorldPosition;
  
        void main() {
  
          float h = normalize( vWorldPosition + offset ).y;
          gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
  
        }
  
      </script>
        <h1></h1>
    
        <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/85/three.min.js'></script>
        
        <script type="module">
               import {
  Color,
  LinearEncoding,
  MeshBasicMaterial,
  Mesh,
  PerspectiveCamera,
  sRGBEncoding,
  Sprite,
  HemisphereLight,
  SpriteMaterial,
  TextureLoader,
  BoxBufferGeometry,
  Scene,
  Vector3,
  WebGLRenderer,
} from "https://unpkg.com/three@0.127.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.127.0/examples/jsm/controls/OrbitControls.js";

import { GLTFLoader } from 'https://unpkg.com/three@0.127.0/examples/jsm/loaders/GLTFLoader.js';

init();

function init() {
    const renderer = new WebGLRenderer();
    renderer.outputEncoding = sRGBEncoding;
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio );
  
    document.body.appendChild( renderer.domElement );
  
    const scene = new Scene();
    scene.background = new Color(0xeeeeee)
  
    const light = new HemisphereLight(0xffffee, 0x444444)
    scene.add(light)

    const camera = new PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 10 );
    camera.position.set(0, 0, 3);
    

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.rotateSpeed = 0.1;
controls.zoomSpeed = 0.9;

controls.minDistance = 3;
controls.maxDistance = 3;

controls.minPolarAngle = 0; // radians
controls.maxPolarAngle = Math.PI /2; // radians

controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;
scene = new THREE.Scene();
scene.background = new THREE.Color().setHSL( 0.6, 0, 1 );
scene.fog = new THREE.Fog( scene.background, 1, 5000 );

    renderer.setAnimationLoop(() => {
      renderer.render( scene, camera );
    });
  
  loadModel(scene)
}

function loadModel(scene) {
  const loader = new GLTFLoader();
  loader.crossOrigin = "anonymous";
  loader.load('https://rawcdn.githack.com/mrdoob/three.js/76d16bd828c8d3e1870eac45aa466c20313cf944/examples/models/gltf/Nefertiti/Nefertiti.glb',(gltf) => {
    
    const model = gltf.scene.children[0]
    model.scale.multiplyScalar(0.1)
    model.position.y = - 1.5
    
    scene.add(model)
    
    createMarker(model, new Vector3(0,17,8))
    createMarker(model, new Vector3(4,15,1.7))
    createMarker(model, new Vector3(-6,0,4))

  })
  
  
}


function createMarker(model, position) {
  const loader = new TextureLoader();
  loader.crossOrigin = "";
  const map = loader.load("https://i.imgur.com/EZynrrA.png");
  map.encoding = sRGBEncoding
  
  const spriteMaterialFront = new SpriteMaterial( { map } );
  
  const spriteFront = new Sprite( spriteMaterialFront );
  spriteFront.position.copy(position) 
  
  const spriteMaterialRear = new SpriteMaterial({ 
    map,
    opacity: 0.3, 
    transparent: true, 
    depthTest: false
  });
  
  const spriteRear = new Sprite( spriteMaterialRear );
  spriteRear.position.copy(position) 
  
  model.add(spriteFront, spriteRear)
}
// LIGHTS

const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
       
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 50, 0 );
				scene.add( hemiLight );

				const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
				scene.add( hemiLightHelper );

				//

				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set( - 1, 1.75, 1 );
				dirLight.position.multiplyScalar( 30 );
				scene.add( dirLight );

				dirLight.castShadow = true;

				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;

				const d = 50;

				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;

				dirLight.shadow.camera.far = 3500;
				dirLight.shadow.bias = - 0.0001;

				const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
				scene.add( dirLightHelper );

				// GROUND

				const groundGeo = new THREE.PlaneGeometry( 10000, 10000 );
				const groundMat = new THREE.MeshLambertMaterial( { color: 0xffffff } );
				groundMat.color.setHSL( 0.095, 1, 0.75 );

				const ground = new THREE.Mesh( groundGeo, groundMat );
				ground.position.y = - 33;
				ground.rotation.x = - Math.PI / 2;
				ground.receiveShadow = true;
				scene.add( ground );

				// SKYDOME

				const vertexShader = document.getElementById( 'vertexShader' ).textContent;
				const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				const uniforms = {
					'topColor': { value: new THREE.Color( 0x0077ff ) },
					'bottomColor': { value: new THREE.Color( 0xffffff ) },
					'offset': { value: 33 },
					'exponent': { value: 0.6 }
				};
				uniforms[ 'topColor' ].value.copy( hemiLight.color );

				scene.fog.color.copy( uniforms[ 'bottomColor' ].value );

				const skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				const skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
				} );

				const sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );
        const params = {
					toggleHemisphereLight: function () {

						hemiLight.visible = ! hemiLight.visible;
						hemiLightHelper.visible = ! hemiLightHelper.visible;

					},
					toggleDirectionalLight: function () {

						dirLight.visible = ! dirLight.visible;
						dirLightHelper.visible = ! dirLightHelper.visible;

					}
				};

				const gui = new GUI();

				gui.add( params, 'toggleHemisphereLight' ).name( 'toggle hemisphere light' );
				gui.add( params, 'toggleDirectionalLight' ).name( 'toggle directional light' );
				gui.open();



            
            
        </script>
    </body>
</html>